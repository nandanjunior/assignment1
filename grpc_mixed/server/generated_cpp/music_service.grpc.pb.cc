// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: music_service.proto

#include "music_service.pb.h"
#include "music_service.grpc.pb.h"

#include <functional>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/impl/channel_interface.h>
#include <grpcpp/impl/client_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/rpc_service_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/support/sync_stream.h>
#include <grpcpp/ports_def.inc>
namespace music {

static const char* MapReduceService_method_names[] = {
  "/music.MapReduceService/AggregateStream",
};

std::unique_ptr< MapReduceService::Stub> MapReduceService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< MapReduceService::Stub> stub(new MapReduceService::Stub(channel, options));
  return stub;
}

MapReduceService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_AggregateStream_(MapReduceService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status MapReduceService::Stub::AggregateStream(::grpc::ClientContext* context, const ::music::StreamList& request, ::music::PlayCounts* response) {
  return ::grpc::internal::BlockingUnaryCall< ::music::StreamList, ::music::PlayCounts, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AggregateStream_, context, request, response);
}

void MapReduceService::Stub::async::AggregateStream(::grpc::ClientContext* context, const ::music::StreamList* request, ::music::PlayCounts* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::music::StreamList, ::music::PlayCounts, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AggregateStream_, context, request, response, std::move(f));
}

void MapReduceService::Stub::async::AggregateStream(::grpc::ClientContext* context, const ::music::StreamList* request, ::music::PlayCounts* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AggregateStream_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::music::PlayCounts>* MapReduceService::Stub::PrepareAsyncAggregateStreamRaw(::grpc::ClientContext* context, const ::music::StreamList& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::music::PlayCounts, ::music::StreamList, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AggregateStream_, context, request);
}

::grpc::ClientAsyncResponseReader< ::music::PlayCounts>* MapReduceService::Stub::AsyncAggregateStreamRaw(::grpc::ClientContext* context, const ::music::StreamList& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAggregateStreamRaw(context, request, cq);
  result->StartCall();
  return result;
}

MapReduceService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      MapReduceService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< MapReduceService::Service, ::music::StreamList, ::music::PlayCounts, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](MapReduceService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::music::StreamList* req,
             ::music::PlayCounts* resp) {
               return service->AggregateStream(ctx, req, resp);
             }, this)));
}

MapReduceService::Service::~Service() {
}

::grpc::Status MapReduceService::Service::AggregateStream(::grpc::ServerContext* context, const ::music::StreamList* request, ::music::PlayCounts* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* UserBehaviorService_method_names[] = {
  "/music.UserBehaviorService/AnalyzeUsers",
};

std::unique_ptr< UserBehaviorService::Stub> UserBehaviorService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< UserBehaviorService::Stub> stub(new UserBehaviorService::Stub(channel, options));
  return stub;
}

UserBehaviorService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_AnalyzeUsers_(UserBehaviorService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status UserBehaviorService::Stub::AnalyzeUsers(::grpc::ClientContext* context, const ::music::StreamList& request, ::music::UserStatsList* response) {
  return ::grpc::internal::BlockingUnaryCall< ::music::StreamList, ::music::UserStatsList, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AnalyzeUsers_, context, request, response);
}

void UserBehaviorService::Stub::async::AnalyzeUsers(::grpc::ClientContext* context, const ::music::StreamList* request, ::music::UserStatsList* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::music::StreamList, ::music::UserStatsList, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AnalyzeUsers_, context, request, response, std::move(f));
}

void UserBehaviorService::Stub::async::AnalyzeUsers(::grpc::ClientContext* context, const ::music::StreamList* request, ::music::UserStatsList* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AnalyzeUsers_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::music::UserStatsList>* UserBehaviorService::Stub::PrepareAsyncAnalyzeUsersRaw(::grpc::ClientContext* context, const ::music::StreamList& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::music::UserStatsList, ::music::StreamList, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AnalyzeUsers_, context, request);
}

::grpc::ClientAsyncResponseReader< ::music::UserStatsList>* UserBehaviorService::Stub::AsyncAnalyzeUsersRaw(::grpc::ClientContext* context, const ::music::StreamList& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAnalyzeUsersRaw(context, request, cq);
  result->StartCall();
  return result;
}

UserBehaviorService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      UserBehaviorService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< UserBehaviorService::Service, ::music::StreamList, ::music::UserStatsList, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](UserBehaviorService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::music::StreamList* req,
             ::music::UserStatsList* resp) {
               return service->AnalyzeUsers(ctx, req, resp);
             }, this)));
}

UserBehaviorService::Service::~Service() {
}

::grpc::Status UserBehaviorService::Service::AnalyzeUsers(::grpc::ServerContext* context, const ::music::StreamList* request, ::music::UserStatsList* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* GenreAnalysisService_method_names[] = {
  "/music.GenreAnalysisService/AnalyzeGenres",
};

std::unique_ptr< GenreAnalysisService::Stub> GenreAnalysisService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< GenreAnalysisService::Stub> stub(new GenreAnalysisService::Stub(channel, options));
  return stub;
}

GenreAnalysisService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_AnalyzeGenres_(GenreAnalysisService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status GenreAnalysisService::Stub::AnalyzeGenres(::grpc::ClientContext* context, const ::music::StreamList& request, ::music::GenreAnalysisResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::music::StreamList, ::music::GenreAnalysisResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_AnalyzeGenres_, context, request, response);
}

void GenreAnalysisService::Stub::async::AnalyzeGenres(::grpc::ClientContext* context, const ::music::StreamList* request, ::music::GenreAnalysisResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::music::StreamList, ::music::GenreAnalysisResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AnalyzeGenres_, context, request, response, std::move(f));
}

void GenreAnalysisService::Stub::async::AnalyzeGenres(::grpc::ClientContext* context, const ::music::StreamList* request, ::music::GenreAnalysisResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_AnalyzeGenres_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::music::GenreAnalysisResponse>* GenreAnalysisService::Stub::PrepareAsyncAnalyzeGenresRaw(::grpc::ClientContext* context, const ::music::StreamList& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::music::GenreAnalysisResponse, ::music::StreamList, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_AnalyzeGenres_, context, request);
}

::grpc::ClientAsyncResponseReader< ::music::GenreAnalysisResponse>* GenreAnalysisService::Stub::AsyncAnalyzeGenresRaw(::grpc::ClientContext* context, const ::music::StreamList& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncAnalyzeGenresRaw(context, request, cq);
  result->StartCall();
  return result;
}

GenreAnalysisService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      GenreAnalysisService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< GenreAnalysisService::Service, ::music::StreamList, ::music::GenreAnalysisResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](GenreAnalysisService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::music::StreamList* req,
             ::music::GenreAnalysisResponse* resp) {
               return service->AnalyzeGenres(ctx, req, resp);
             }, this)));
}

GenreAnalysisService::Service::~Service() {
}

::grpc::Status GenreAnalysisService::Service::AnalyzeGenres(::grpc::ServerContext* context, const ::music::StreamList* request, ::music::GenreAnalysisResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* RecommendationService_method_names[] = {
  "/music.RecommendationService/Recommend",
};

std::unique_ptr< RecommendationService::Stub> RecommendationService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< RecommendationService::Stub> stub(new RecommendationService::Stub(channel, options));
  return stub;
}

RecommendationService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options)
  : channel_(channel), rpcmethod_Recommend_(RecommendationService_method_names[0], options.suffix_for_stats(),::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status RecommendationService::Stub::Recommend(::grpc::ClientContext* context, const ::music::RecommendationRequest& request, ::music::RecommendationResponse* response) {
  return ::grpc::internal::BlockingUnaryCall< ::music::RecommendationRequest, ::music::RecommendationResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), rpcmethod_Recommend_, context, request, response);
}

void RecommendationService::Stub::async::Recommend(::grpc::ClientContext* context, const ::music::RecommendationRequest* request, ::music::RecommendationResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc::internal::CallbackUnaryCall< ::music::RecommendationRequest, ::music::RecommendationResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Recommend_, context, request, response, std::move(f));
}

void RecommendationService::Stub::async::Recommend(::grpc::ClientContext* context, const ::music::RecommendationRequest* request, ::music::RecommendationResponse* response, ::grpc::ClientUnaryReactor* reactor) {
  ::grpc::internal::ClientCallbackUnaryFactory::Create< ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(stub_->channel_.get(), stub_->rpcmethod_Recommend_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::music::RecommendationResponse>* RecommendationService::Stub::PrepareAsyncRecommendRaw(::grpc::ClientContext* context, const ::music::RecommendationRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderHelper::Create< ::music::RecommendationResponse, ::music::RecommendationRequest, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(channel_.get(), cq, rpcmethod_Recommend_, context, request);
}

::grpc::ClientAsyncResponseReader< ::music::RecommendationResponse>* RecommendationService::Stub::AsyncRecommendRaw(::grpc::ClientContext* context, const ::music::RecommendationRequest& request, ::grpc::CompletionQueue* cq) {
  auto* result =
    this->PrepareAsyncRecommendRaw(context, request, cq);
  result->StartCall();
  return result;
}

RecommendationService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      RecommendationService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< RecommendationService::Service, ::music::RecommendationRequest, ::music::RecommendationResponse, ::grpc::protobuf::MessageLite, ::grpc::protobuf::MessageLite>(
          [](RecommendationService::Service* service,
             ::grpc::ServerContext* ctx,
             const ::music::RecommendationRequest* req,
             ::music::RecommendationResponse* resp) {
               return service->Recommend(ctx, req, resp);
             }, this)));
}

RecommendationService::Service::~Service() {
}

::grpc::Status RecommendationService::Service::Recommend(::grpc::ServerContext* context, const ::music::RecommendationRequest* request, ::music::RecommendationResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace music
#include <grpcpp/ports_undef.inc>

